#include "assignment1.h"
/*fibonachi function*/
int fib(int N)
{
  int i;
  int answer;
  int tmp;
  int counter;
  i = 0;
  answer = 1;
  for(counter = 1 ; counter <= N; counter++)
    {
      tmp = i + answer;
      i = answer;
      answer = tmp;
    }
  return answer;
}
/*producer function - takes care of creating products*/
void *producer(void *args)
{
  for (int tid = *((int*)args);nprod < maxprod;)
    {
      pthread_mutex_lock(&mutex);
      for (;qsize > 0 && products.size() == qsize && nprod < maxprod;)
	pthread_cond_wait(&qempty, &mutex);
      if (nprod < maxprod)
        {
	  Product *prod = (Product *) malloc(sizeof(Product));
	  prod->timestamp = clock();
	  prod->id = nprod++;
	  prod->life = random() % 1024;
	  products.push_front(prod);
	  
	  cout << "[!!]Producer with id [" << tid<< "] produced the product with id [" << products.front()->id << "]"<< endl;
        }
      fflush(stdout);
      pthread_mutex_unlock(&mutex);
      pthread_cond_broadcast(&qfull);
      usleep(100000);
    }
  pendtime = clock();
  return NULL;
}
/*consumer function - takes care of consuming products*/
void *consumer(void *args)
{
  int i;
  float curr;
  for (int tid = *((int *) args);usedprod < maxprod;)
    {
      pthread_mutex_lock(&mutex);
      for (;usedprod < maxprod && products.size() == 0;)
	pthread_cond_wait(&qfull, &mutex);
      curr=clock();
      if (sched == 0)
        {
	  Product *prod = products.back();
	  if (prod != NULL)
            {
	      totalt +=  curr - prod->timestamp;
	      if (curr - prod->timestamp < minwaitt)
		minwaitt = curr - prod->timestamp;
	      if (curr - prod->timestamp > maxwaitt)               
		maxwaitt = curr - prod->timestamp; 
	      for (i = 0; i < prod->life; i++)
		fib(10);

	      cout << "[!!]Consumer with id [" << tid  << "] consumed the product with id [" << prod->id <<"]"<< endl;
	      products.pop_back();
	      ++usedprod;
	      if (curr - prod->timestamp < mincont)
		mincont = curr - prod->timestamp;
	      if (curr - prod->timestamp > maxcont)
		maxcont = curr - prod->timestamp;
            }
        }
      else if (sched = 1)
        {
	  Product *prod = products.front();
	  if (prod != NULL)
            {
	      if (curr - prod->timestamp < minwaitt)
		minwaitt = curr - prod->timestamp;
	      if (curr - prod->timestamp > maxwaitt)
		maxwaitt = curr - prod->timestamp;
	      products.pop_front();
	      if (prod->life >= quantum)
                {
		  prod->life -= quantum;
		  for (i = 0; i < quantum; i++)
		    fib(10);
		  products.push_back(prod);
                }
	      else
                {
		  totalt += curr - prod->timestamp;
		  for (i = 0; i < prod->life; i++)
		    fib(10);
		  cout << "[!!]Consumer with id [" <<  tid << "] consumed the product with id [" << prod->id << "]"<< endl;
		  ++usedprod;
		  if (curr - prod->timestamp < mincont)
		    mincont = curr - prod->timestamp;
		  if (curr - prod->timestamp > maxcont)
		    maxcont = curr - prod->timestamp;
                }
            }
        
        }
      /*flushing output, unlocking mutex and sending signals*/
      fflush(stdout);
      pthread_mutex_unlock(&mutex);
      pthread_cond_broadcast(&qempty);
      usleep(100000);
    }
  cendtime = clock();
  return NULL;
}
/*main - is here*/
int main(int argc, char **argv)
{
  int nprod1;
  int qsize1;  
  int n;
  int prodt;
  int alg;
  int quantum1;
  int seed1;
  int consumt;
  int i;
  int *ret;
  clock_t end_time;
  /*checking the number of arguments*/
  if (argc != 8)
    {
      cerr << "usage: ./main [Number of producer threads] [Number of consumer threads] [Total number of products to be generated by all producer threads] [Size of the queue to store products for both producer and consumer threads (0 for unlimited queue size)] [0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for Round-Robin] [Value of quantum used for round-robin scheduling] [Seed for random number generator]" << endl;
      exit(1);
    }
  /*setting arguments*/
  prodt = atoi(argv[1]);
  consumt = atoi(argv[2]);
  nprod1= atoi(argv[3]);
  qsize1 = atoi(argv[4]);
  alg = atoi(argv[5]);
  quantum1 = atoi(argv[6]);
  seed1 = atoi(argv[7]);
  /*error messages*/
  if (consumt <= 0)
    {
      cerr << "[++]Invalid number of consumer threads" << endl;
      exit(0);
    }
  if (prodt <= 0)
    {
      cerr << "[++]Invalid number of producer threads" << endl;
      exit(0);
    }
  if (alg < 0 || alg > 1)
    {
      cerr << "[++]Invalid search algorithm" << endl;
      exit(0);
    }
  if (qsize1 < 0)
    {
      cerr << "[++]Invalid queue size" << endl;
      exit(0);
    }
  if (nprod1 < 0)
    {
      cerr << "[++]Invalid number of products" << endl;
      exit(0);
    }
  if (quantum < 0)
    {
      cerr << "[++]Invalid quantum" << endl;
      exit(0);
    }
  /*generating random seed*/
  srand(seed1);
  pthread_t producerThreads[prodt];
  pthread_t consumerThreads[consumt];
  nprod = 0;
  usedprod = 0;
  maxprod = nprod1;
  quantum = quantum1;
  qsize = qsize1;
  sched = alg;
  /*initializing conds and mutex*/
  pthread_mutex_init(&mutex, NULL);
  pthread_cond_init(&qempty, NULL);
  pthread_cond_init(&qfull, NULL);
  start_time = clock();
  /*creating producer threads*/
  for (i = 0; i < prodt; i++)
    {
      if (n = pthread_create(&producerThreads[i], NULL, &producer, &i))
	cout << "Couldn't create a producer thread: " << n << endl;
    }
  cstarttime = clock();
  /*creating consumer threads*/
  for (i = 0; i < consumt; i++)
    {
      if (n = pthread_create(&consumerThreads[i], NULL, &consumer, &i))
	cout << "Couldn't create a consumer thread: " << n << endl;
    }
  /*joining threads*/
  for (i = 0; i < prodt; i++)
    pthread_join(producerThreads[i], NULL);

  for (i = 0; i < consumt; i++)
    pthread_join(consumerThreads[i], NULL);
  /*destroying conds and mutex*/
  pthread_cond_destroy(&qempty);
  pthread_cond_destroy(&qfull);
  pthread_mutex_destroy(&mutex);
  end_time = clock();
  /*time stuff*/
  cout << "------------------------------------------------------------"<< endl;
  cout << "Total consumption time: " << (cendtime - cstarttime)/(float)10000 << " sec."<< endl;
  cout << "Min turn-around time: " << mincont/(float)10000 << " sec."<< endl;
  cout << "Max turn-around time: "<< maxcont/(float)10000 << " sec."<< endl;
  cout << "Average turn-aound time: "<< (cendtime - cstarttime)/(maxprod * (float)10000) << " sec."<< endl;
  cout << "Min wait time: "<< minwaitt/(float)10000 << " sec." << endl;
  cout << "Max wait time: "<< maxwaitt/(float)10000 << " sec." << endl;
  cout << "Averate wait time: "<< totalt/((float)10000 * maxprod)<<" sec." << endl;
  cout << "Producer throughput: "<< maxprod/((pendtime - start_time)*(float)10000)<< " products/sec." << endl;
  cout << "Consumer throughput: "<< maxprod/((cendtime - start_time)*(float)10000)<< " products/sec." << endl;
  return 0;
}
