#include "assignment1.h"
/*Vladislav Ligai*/
/*Assignmen 1*/
/*The goal of this assignment is to simulate a producer-consumer system using threads, mutexes, condition variables and scheduling. You will experiment with varying the numbers of available producer and consumer threads, the number of products, and the scheduling algorithm used to schedule the consumption of products. Your program must accept the following parameters at the command prompt in the order specified*/
/*fibonachi function*/
int fib(int N)
{
  int i;
  int answer;
  int tmp;
  int counter;
  i = 0;
  answer = 1;
  for(counter = 1 ; counter <= N; counter++)
    {
      tmp = i + answer;
      i = answer;
      answer = tmp;
    }
  return answer;
}
/*producer function - takes care of creating products*/
void *producer(void *args)
{
  for (int tid = *((int*)args);nprod < maxprod;)
    {
      /*locking mutex*/
      pthread_mutex_lock(&mutex);
      /*waiting*/
      for (;qsize > 0 && products.size() == qsize && nprod < maxprod;)
	pthread_cond_wait(&qempty, &mutex);
      if (nprod < maxprod)
        {
	  /*creating a product*/
	  Product *prod = (Product *) malloc(sizeof(Product));
	  prod->timestamp = clock();
	  /*product id assigned here*/
	  prod->id = nprod++;
	  prod->life = random() % 1024;
	  products.push_front(prod);
	  
	  cout << "[!]Producer with id [" << tid<< "] produced the product with id [" << products.front()->id << "]"<< endl;
        }
      /*flushing output, unlocking mutex and signaling*/
      fflush(stdout);
      pthread_mutex_unlock(&mutex);
      pthread_cond_broadcast(&qfull);
      usleep(100000);
    }
  /*setting producer end time*/
  pendtime = clock();
  return NULL;
}
/*consumer function - takes care of consuming products*/
void *consumer(void *args)
{
  int i;
  float curr;
  for (int tid = *((int *) args);usedprod < maxprod;)
    {
      /*locking mutex*/
      pthread_mutex_lock(&mutex);
      for (;usedprod < maxprod && products.size() == 0;)
	pthread_cond_wait(&qfull, &mutex);
      curr=clock();
      /*first come first serve*/
      if (sched == 0)
        {
	  Product *prod = products.back();
	  if (prod != NULL)
            {
	      /*setting minimum and maximum waiting time*/
	      totalt +=  curr - prod->timestamp;
	      if (curr - prod->timestamp > maxwaitt)               
		maxwaitt = curr - prod->timestamp; 
	      if (curr - prod->timestamp < minwaitt)
		minwaitt = curr - prod->timestamp;
	      for (i = 0; i < prod->life; i++)
		fib(10);

	      cout << "[!]Consumer with id [" << tid  << "] consumed the product with id [" << prod->id <<"]"<< endl;
	      products.pop_back();
	      ++usedprod;
	      /*setting minimum and mamximum consumption times*/
	      if (curr - prod->timestamp > maxcont)
		maxcont = curr - prod->timestamp;
	      if (curr - prod->timestamp < mincont)
		mincont = curr - prod->timestamp;
            }
        }
      /*round robin*/
      else if (sched = 1)
        {
	  Product *prod = products.front();
	  if (prod != NULL)
            {
	      /*setting max and mid wait times*/
	      if (curr - prod->timestamp > maxwaitt)
		maxwaitt = curr - prod->timestamp;
	      if (curr - prod->timestamp < minwaitt)
		minwaitt = curr - prod->timestamp;
	      products.pop_front();
	      if (prod->life >= quantum)
                {
		  prod->life -= quantum;
		  for (i = 0; i < quantum; i++)
		    fib(10);
		  products.push_back(prod);
                }
	      else
                {
		  totalt += curr - prod->timestamp;
		  for (i = 0; i < prod->life; i++)
		    fib(10);
		  cout << "[!]Consumer with id [" <<  tid << "] consumed the product with id [" << prod->id << "]"<< endl;
		  ++usedprod;
		  /*setting min and max consumption time*/
		  if (curr - prod->timestamp < mincont)
		    mincont = curr - prod->timestamp;
		  if (curr - prod->timestamp > maxcont)
		    maxcont = curr - prod->timestamp;
                }
            }
        
        }
      /*flushing output, unlocking mutex and sending signals*/
      fflush(stdout);
      pthread_mutex_unlock(&mutex);
      pthread_cond_broadcast(&qempty);
      usleep(100000);
    }
  cendtime = clock();
  return NULL;
}
/*main - is here*/
int main(int argc, char **argv)
{
  int nprod1;
  int qsize1;  
  int n;
  int prodt;
  int alg;
  int quantum1;
  int seed1;
  int consumt;
  int i;
  clock_t end_time;
  /*checking the number of arguments*/
  if (argc != 8)
    {
      cerr << "usage: ./main [Number of producer threads] [Number of consumer threads] [Total number of products to be generated by all producer threads] [Size of the queue to store products for both producer and consumer threads (0 for unlimited queue size)] [0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for Round-Robin] [Value of quantum used for round-robin scheduling] [Seed for random number generator]" << endl;
      exit(1);
    }
  /*setting arguments*/
  prodt = atoi(argv[1]);
  consumt = atoi(argv[2]);
  nprod1= atoi(argv[3]);
  qsize1 = atoi(argv[4]);
  alg = atoi(argv[5]);
  quantum1 = atoi(argv[6]);
  seed1 = atoi(argv[7]);
  /*error messages*/
  if (consumt <= 0)
    {
      cerr << "[++]Invalid number of consumer threads" << endl;
      exit(0);
    }
  if (prodt <= 0)
    {
      cerr << "[++]Invalid number of producer threads" << endl;
      exit(0);
    }
  if (alg < 0 || alg > 1)
    {
      cerr << "[++]Invalid search algorithm" << endl;
      exit(0);
    }
  if (qsize1 < 0)
    {
      cerr << "[++]Invalid queue size" << endl;
      exit(0);
    }
  if (nprod1 < 0)
    {
      cerr << "[++]Invalid number of products" << endl;
      exit(0);
    }
  if (quantum < 0)
    {
      cerr << "[++]Invalid quantum" << endl;
      exit(0);
    }
  /*generating random seed*/
  srand(seed1);
  pthread_t producerThreads[prodt];
  pthread_t consumerThreads[consumt];
  nprod = 0;
  usedprod = 0;
  maxprod = nprod1;
  quantum = quantum1;
  qsize = qsize1;
  sched = alg;
  /*initializing conds and mutex*/
  pthread_mutex_init(&mutex, NULL);
  pthread_cond_init(&qempty, NULL);
  pthread_cond_init(&qfull, NULL);
  start_time = clock();
  /*creating producer threads*/
  for (i = 0; i < prodt; i++)
    {
      if (n = pthread_create(&producerThreads[i], NULL, &producer, &i))
	cout << "Couldn't create a producer thread: " << n << endl;
    }
  cstarttime = clock();
  /*creating consumer threads*/
  for (i = 0; i < consumt; i++)
    {
      if (n = pthread_create(&consumerThreads[i], NULL, &consumer, &i))
	cout << "Couldn't create a consumer thread: " << n << endl;
    }
  /*joining threads*/
  for (i = 0; i < prodt; i++)
    pthread_join(producerThreads[i], NULL);

  for (i = 0; i < consumt; i++)
    pthread_join(consumerThreads[i], NULL);
  /*destroying conds and mutex*/
  pthread_cond_destroy(&qempty);
  pthread_cond_destroy(&qfull);
  pthread_mutex_destroy(&mutex);
  end_time = clock();
  /*time stuff*/
  cout << "------------------------------------------------------------"<< endl;
  cout << "Total consumption time: " << (cendtime - cstarttime)/(float)10000 << " sec."<< endl;
  cout << "Min turn-around time: " << mincont/(float)10000 << " sec."<< endl;
  cout << "Max turn-around time: "<< maxcont/(float)10000 << " sec."<< endl;
  cout << "Average turn-aound time: "<< (cendtime - cstarttime)/(maxprod * (float)10000) << " sec."<< endl;
  cout << "Min wait time: "<< minwaitt/(float)10000 << " sec." << endl;
  cout << "Max wait time: "<< maxwaitt/(float)10000 << " sec." << endl;
  cout << "Averate wait time: "<< totalt/((float)10000 * maxprod)<<" sec." << endl;
  cout << "Producer throughput: "<< (int)60*(maxprod/(((pendtime - start_time))/((float)10000)))<< " products/min." << endl;
  cout << "Consumer throughput: "<< (int)60*(maxprod/(((cendtime - start_time))/((float)10000)))<< " products/min." << endl;
  return 0;
}
    
